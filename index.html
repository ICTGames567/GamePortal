<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>GamePortal</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body class="light">
  <!-- NAVBAR -->
  <nav class="navbar">
    <div class="logo" role="button" tabindex="0" id="logoHome">GamePortal</div>

    <div class="theme-switch" aria-label="Theme Switch">
      <span>Light</span>
      <div id="modeToggle" class="switch" role="button" tabindex="0" aria-label="Light/Dark umschalten">
        <div class="knob"></div>
      </div>
      <span>Dark</span>
    </div>
  </nav>

  <!-- HOME -->
  <section class="screen show" id="screen-home" aria-label="Homepage">
    <header class="hero">
      <h1>Game Portal</h1>
      <p>W√§hle ein Spiel aus und starte sofort</p>
    </header>

    <main class="games">
      <div class="game-card" data-open="ttt">
        <h2>Spiel 1: Tic Tac Toe</h2>
        <p>2 Spieler oder gegen Bot (leicht/mittel/schwer)</p>
      </div>

      <div class="game-card" data-open="snake">
        <h2>Spiel 2: Snake</h2>
        <p>Wand-Modus + Handy-Steuerung mit Pfeilen</p>
      </div>

      <div class="game-card" data-open="flappy">
        <h2>Spiel 3: Flappy Bird</h2>
        <p>Start-Button + Schwierigkeit</p>
      </div>

      <div class="game-card" data-open="minigolf">
        <h2>Spiel 4: MiniGolf</h2>
        <p>25 Level ‚Ä¢ Bounce-Pads ‚Ä¢ Runde Hindernisse ‚Ä¢ Moving Obstacles</p>
      </div>

      <a class="game-card link-card" href="http://massi2912.github.io/Coockie/" target="_blank" rel="noreferrer">
        <h2>Extra: Cookie Clicker</h2>
        <p>√ñffnet externe Seite</p>
      </a>
    </main>
  </section>

  <!-- TTT -->
  <section class="screen" id="screen-ttt" aria-label="Tic Tac Toe">
    <header class="topbar">
      <button class="btn ghost" data-home type="button">Home</button>
      <div class="topTitle">
        <h2>Tic Tac Toe</h2>
        <p>Babyblau Theme ‚Ä¢ kinderfreundlich ‚Ä¢ mobil stabil</p>
      </div>
      <div class="topRight"></div>
    </header>

    <div class="appGrid">
      <aside class="panel">
        <div class="panelBox">
          <div class="row2">
            <div class="field">
              <label for="tttMode">Modus</label>
              <select id="tttMode">
                <option value="pvp">2 Spieler</option>
                <option value="bot">Gegen Bot</option>
              </select>
            </div>

            <div class="field">
              <label for="tttDiff">Schwierigkeit</label>
              <select id="tttDiff">
                <option value="easy">Leicht</option>
                <option value="medium" selected>Mittel</option>
                <option value="hard">Schwer</option>
              </select>
            </div>
          </div>

          <div class="actions">
            <button class="btn primary" id="tttNew">Neues Spiel</button>
            <button class="btn" id="tttResetScores">Punkte zur√ºcksetzen</button>
          </div>
        </div>

        <div class="statusCard">
          <div class="statusLeft">
            <span class="dot" id="tttDot"></span>
            <span id="tttStatus">X ist dran</span>
          </div>
          <div class="meta" id="tttMeta">2 Spieler</div>
        </div>

        <div class="scoreCard">
          <div class="pills">
            <span class="pill">X: <strong id="tttScoreX">0</strong></span>
            <span class="pill">O: <strong id="tttScoreO">0</strong></span>
            <span class="pill">Remis: <strong id="tttScoreD">0</strong></span>
          </div>
          <div class="meta">Schwer spielt perfekt.</div>
        </div>
      </aside>

      <main class="boardArea">
        <div class="boardWrap">
          <div class="board" id="tttBoard" aria-label="TTT Spielbrett">
            <button class="cell" data-i="0" aria-label="Feld 1"></button>
            <button class="cell" data-i="1" aria-label="Feld 2"></button>
            <button class="cell" data-i="2" aria-label="Feld 3"></button>
            <button class="cell" data-i="3" aria-label="Feld 4"></button>
            <button class="cell" data-i="4" aria-label="Feld 5"></button>
            <button class="cell" data-i="5" aria-label="Feld 6"></button>
            <button class="cell" data-i="6" aria-label="Feld 7"></button>
            <button class="cell" data-i="7" aria-label="Feld 8"></button>
            <button class="cell" data-i="8" aria-label="Feld 9"></button>
          </div>
        </div>

        <div class="overlay" id="tttOverlay" aria-live="polite">
          <div class="modal">
            <p class="modalTitle" id="tttModalTitle">Gewinner</p>
            <p class="modalBig" id="tttModalBig">‚Äî</p>
            <p class="modalSub">Neues Spiel starten</p>
          </div>
        </div>
      </main>
    </div>
  </section>

  <!-- SNAKE -->
  <section class="screen" id="screen-snake" aria-label="Snake">
    <header class="topbar">
      <button class="btn ghost" data-home type="button">Home</button>
      <div class="topTitle">
        <h2>Snake</h2>
        <p>WASD/Pfeile (Desktop) ‚Ä¢ Swipe + Pfeile (Mobile)</p>
      </div>
      <div class="topRight"></div>
    </header>

    <div class="appGrid">
      <aside class="panel">
        <div class="panelBox">
          <div class="row2">
            <div class="field">
              <label for="snSpeed">Geschwindigkeit</label>
              <select id="snSpeed">
                <option value="slow">Langsam</option>
                <option value="normal" selected>Normal</option>
                <option value="fast">Schnell</option>
              </select>
            </div>
            <div class="field">
              <label for="snSize">Spielfeld</label>
              <select id="snSize">
                <option value="16">Einfach (16√ó16)</option>
                <option value="20" selected>Normal (20√ó20)</option>
                <option value="26">Gro√ü (26√ó26)</option>
              </select>
            </div>
          </div>

          <div class="actions">
            <button class="btn wallToggle" id="snWallBtn" type="button">
              <span class="toggleLeft">
                <span class="toggleTitle">Wand-Modus</span>
                <span class="toggleHint" id="snWallHint">AUS (Wrap)</span>
              </span>
              <span class="miniSwitch" aria-hidden="true"><span class="miniKnob"></span></span>
            </button>

            <button class="btn primary" id="snNew">Neues Spiel</button>
            <button class="btn" id="snPause">Pause</button>
          </div>
        </div>

        <div class="statusCard">
          <div class="statusLeft">
            <span class="dot mint"></span>
            <span id="snStatus">Bereit</span>
          </div>
          <div class="scoreBig">
            <span class="scoreLabel">Punkte</span>
            <span class="scoreNumber" id="snScore">0</span>
          </div>
        </div>

        <div class="helpCard">
          <div><strong>Desktop:</strong> WASD / Pfeile ‚Ä¢ <strong>Pause:</strong> Leertaste</div>
          <div><strong>Handy:</strong> Swipe oder Pfeile unten</div>
        </div>
      </aside>

      <main class="boardArea">
        <div class="boardWrap">
          <div class="canvasShell">
            <canvas id="snCanvas" aria-label="Snake Spielfeld" tabindex="0"></canvas>
          </div>
        </div>

        <div class="overlay" id="snOverlay" aria-live="polite">
          <div class="modal">
            <p class="modalTitle">Game Over</p>
            <p class="modalBig" id="snModalBig">Punkte: 0</p>
            <p class="modalSub">Dr√ºcke ‚ÄûNeues Spiel‚Äú</p>
          </div>
        </div>

        <!-- Mobile D-Pad (nur auf Mobile sichtbar via CSS) -->
        <div class="dpad" id="snDpad" aria-label="Mobile Steuerung">
          <button class="dbtn up" data-dir="up" type="button">‚ñ≤</button>
          <button class="dbtn left" data-dir="left" type="button">‚óÄ</button>
          <button class="dbtn mid" data-dir="pause" type="button">‚èØ</button>
          <button class="dbtn right" data-dir="right" type="button">‚ñ∂</button>
          <button class="dbtn down" data-dir="down" type="button">‚ñº</button>
        </div>
      </main>
    </div>
  </section>

  <!-- FLAPPY -->
  <section class="screen" id="screen-flappy" aria-label="Flappy Bird">
    <header class="topbar">
      <button class="btn ghost" data-home type="button">Home</button>
      <div class="topTitle">
        <h2>Flappy Bird</h2>
        <p>Tippen/Klicken zum Fliegen ‚Ä¢ Start-Button ‚Ä¢ Schwierigkeit</p>
      </div>
      <div class="topRight"></div>
    </header>

    <div class="appGrid">
      <aside class="panel">
        <div class="panelBox">
          <div class="row2">
            <div class="field">
              <label for="fbDiff">Schwierigkeit</label>
              <select id="fbDiff">
                <option value="easy">Leicht (langsamer)</option>
                <option value="normal" selected>Normal</option>
                <option value="hard">Schwer (schneller)</option>
              </select>
            </div>
            <div class="field">
              <label for="fbMode">Modus</label>
              <select id="fbMode">
                <option value="classic" selected>Klassisch</option>
                <option value="tight">Enger</option>
              </select>
            </div>
          </div>

          <div class="actions">
            <button class="btn primary" id="fbStart">Start</button>
            <button class="btn" id="fbReset">Reset</button>
          </div>
        </div>

        <div class="statusCard">
          <div class="statusLeft">
            <span class="dot pink"></span>
            <span id="fbStatus">Bereit</span>
          </div>
          <div class="scoreBig">
            <span class="scoreLabel">Score</span>
            <span class="scoreNumber" id="fbScore">0</span>
          </div>
        </div>

        <div class="helpCard">
          <div><strong>Steuerung:</strong> Tippen/Klicken oder Leertaste</div>
          <div><strong>Tipp:</strong> Ruhig bleiben ‚Äì kleine Flaps!</div>
        </div>
      </aside>

      <main class="boardArea">
        <div class="boardWrap">
          <div class="canvasShell">
            <canvas id="fbCanvas" aria-label="Flappy Spiel" tabindex="0"></canvas>
          </div>
        </div>

        <div class="overlay" id="fbOverlay" aria-live="polite">
          <div class="modal">
            <p class="modalTitle">Game Over</p>
            <p class="modalBig" id="fbModalBig">Score: 0</p>
            <p class="modalSub">Dr√ºcke ‚ÄûStart‚Äú</p>
          </div>
        </div>
      </main>
    </div>
  </section>

  <!-- MINIGOLF -->
  <section class="screen" id="screen-minigolf" aria-label="MiniGolf">
    <header class="topbar">
      <button class="btn ghost" data-home type="button">Home</button>
      <div class="topTitle">
        <h2>MiniGolf</h2>
        <p>Ball ziehen & loslassen ‚Ä¢ 25 Level</p>
      </div>
      <div class="topRight"></div>
    </header>

    <div class="miniHud">
      <div class="pill">Level: <strong id="mgLevel">1</strong>/25</div>
      <div class="pill">Schl√§ge: <strong id="mgStrokes">0</strong></div>
      <div class="pill">Best: <strong id="mgBest">‚Äì</strong></div>
      <button class="btn" id="mgReset" type="button">Reset</button>
      <button class="btn" id="mgPrev" type="button">‚óÄ</button>
      <button class="btn" id="mgNext" type="button">‚ñ∂</button>
    </div>

    <main class="miniStage">
      <div class="canvasShell big">
        <canvas id="mgCanvas" aria-label="MiniGolf Spielfeld"></canvas>
      </div>
    </main>

    <div class="toast" id="mgToast">Level geschafft! üéâ</div>
  </section>

<script>
/* =========================
   PORTAL NAV + THEME
========================= */
const body = document.body;
const toggle = document.getElementById("modeToggle");
const logoHome = document.getElementById("logoHome");

function setTheme(theme){
  body.classList.toggle("dark", theme === "dark");
  body.classList.toggle("light", theme !== "dark");
  toggle.classList.toggle("active", theme === "dark");
  localStorage.setItem("gp_theme", theme);
}
setTheme(localStorage.getItem("gp_theme") || "light");

toggle.addEventListener("click", ()=> setTheme(body.classList.contains("dark") ? "light" : "dark"));
toggle.addEventListener("keydown", (e)=> { if(e.key==="Enter"||e.key===" "){ e.preventDefault(); toggle.click(); }});

function showScreen(name){
  document.querySelectorAll(".screen").forEach(s => s.classList.remove("show"));
  document.getElementById("screen-" + name).classList.add("show");
  window.scrollTo({top:0, behavior:"instant"});
}

document.querySelectorAll("[data-home]").forEach(b => b.addEventListener("click", ()=> showScreen("home")));
logoHome.addEventListener("click", ()=> showScreen("home"));
logoHome.addEventListener("keydown", (e)=> { if(e.key==="Enter"||e.key===" "){ e.preventDefault(); showScreen("home"); }});

document.querySelectorAll("[data-open]").forEach(card => {
  card.addEventListener("click", ()=> {
    const target = card.getAttribute("data-open");
    showScreen(target);
    // fokus aufs canvas falls vorhanden
    if(target==="snake") document.getElementById("snCanvas").focus();
    if(target==="flappy") document.getElementById("fbCanvas").focus();
  });
});

/* =========================
   TTT
========================= */
(() => {
  const cells = Array.from(document.querySelectorAll("#tttBoard .cell"));
  const statusText = document.getElementById("tttStatus");
  const metaText = document.getElementById("tttMeta");
  const modeSelect = document.getElementById("tttMode");
  const diffSelect = document.getElementById("tttDiff");
  const newBtn = document.getElementById("tttNew");
  const resetScoresBtn = document.getElementById("tttResetScores");
  const dot = document.getElementById("tttDot");

  const overlay = document.getElementById("tttOverlay");
  const modalTitle = document.getElementById("tttModalTitle");
  const modalBig = document.getElementById("tttModalBig");

  const scoreXEl = document.getElementById("tttScoreX");
  const scoreOEl = document.getElementById("tttScoreO");
  const scoreDEl = document.getElementById("tttScoreD");

  const HUMAN = "X";
  const BOT = "O";
  const WIN_LINES = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
  ];

  let board = Array(9).fill(null);
  let current = "X";
  let gameOver = false;
  let scores = {X:0, O:0, D:0};

  function setDotFor(p){
    dot.classList.remove("x","o");
    if(p==="X") dot.classList.add("x");
    else if(p==="O") dot.classList.add("o");
  }

  function updateMeta(){
    const isBot = modeSelect.value === "bot";
    diffSelect.disabled = !isBot;
    const d = diffSelect.value;
    const diffLabel = d==="easy"?"Leicht":d==="medium"?"Mittel":"Schwer";
    metaText.textContent = isBot ? ("Gegen Bot ¬∑ " + diffLabel) : "2 Spieler";
  }

  function checkWinner(b){
    for(const line of WIN_LINES){
      const [a,b1,c] = line;
      if(b[a] && b[a]===b[b1] && b[a]===b[c]) return {winner:b[a], line};
    }
    if(b.every(v=>v!==null)) return {winner:"D", line:null};
    return null;
  }

  function showOverlay(w){
    if(w==="D"){
      modalTitle.textContent = "Ergebnis";
      modalBig.textContent = "Remis";
    } else {
      modalTitle.textContent = "Gewinner";
      modalBig.textContent = w;
    }
    overlay.classList.add("show");
    clearTimeout(showOverlay._t);
    showOverlay._t = setTimeout(()=> overlay.classList.remove("show"), 1200);
  }

  function render(){
    cells.forEach((c,i)=>{
      const v = board[i];
      c.textContent = v || "";
      c.classList.toggle("x", v==="X");
      c.classList.toggle("o", v==="O");
      c.classList.remove("win");
      c.disabled = gameOver || v!==null;
    });
    scoreXEl.textContent = scores.X;
    scoreOEl.textContent = scores.O;
    scoreDEl.textContent = scores.D;
    updateMeta();
  }

  function highlight(line){
    if(!line) return;
    line.forEach(i=> cells[i].classList.add("win"));
  }

  function end(result){
    gameOver = true;
    if(result.winner==="D"){
      scores.D++;
      statusText.textContent = "Unentschieden";
      showOverlay("D");
    } else {
      scores[result.winner]++;
      statusText.textContent = result.winner + " gewinnt";
      highlight(result.line);
      showOverlay(result.winner);
    }
    render();
  }

  function switchTurn(){
    current = (current==="X") ? "O" : "X";
    statusText.textContent = current + " ist dran";
    setDotFor(current);
  }

  function randomMove(){
    const empty = board.map((v,i)=> v===null ? i : null).filter(v=>v!==null);
    return empty.length ? empty[Math.floor(Math.random()*empty.length)] : null;
  }
  function strategicMove(){
    if(board[4]===null) return 4;
    const corners=[0,2,6,8].filter(i=>board[i]===null);
    if(corners.length) return corners[Math.floor(Math.random()*corners.length)];
    const edges=[1,3,5,7].filter(i=>board[i]===null);
    if(edges.length) return edges[Math.floor(Math.random()*edges.length)];
    return null;
  }
  function findImmediate(player){
    for(let i=0;i<9;i++){
      if(board[i]!==null) continue;
      const test=board.slice();
      test[i]=player;
      const r=checkWinner(test);
      if(r && r.winner===player) return i;
    }
    return null;
  }
  function minimaxBest(state, player){
    const r = checkWinner(state);
    if(r){
      if(r.winner===BOT) return {score:10};
      if(r.winner===HUMAN) return {score:-10};
      return {score:0};
    }
    const moves=[];
    for(let i=0;i<9;i++){
      if(state[i]!==null) continue;
      const next=state.slice();
      next[i]=player;
      const nextPlayer=(player===BOT)?HUMAN:BOT;
      const out=minimaxBest(next,nextPlayer);
      moves.push({index:i, score: out.score + (player===BOT ? -0.01 : 0.01)});
    }
    let best=moves[0];
    if(player===BOT){
      for(const m of moves) if(m.score>best.score) best=m;
    } else {
      for(const m of moves) if(m.score<best.score) best=m;
    }
    return best;
  }

  function botMove(){
    if(gameOver) return;
    const d = diffSelect.value;
    let move=null;
    if(d==="easy") move=randomMove();
    else if(d==="medium"){
      move = (Math.random()<0.7) ? (findImmediate(BOT) ?? findImmediate(HUMAN) ?? strategicMove() ?? randomMove()) : randomMove();
    } else {
      move = minimaxBest(board, BOT).index;
    }
    if(move!=null) makeMove(move);
  }

  function makeMove(i){
    if(gameOver || board[i]!==null) return;
    board[i]=current;

    const r = checkWinner(board);
    render();
    if(r){ end(r); return; }

    switchTurn();
    if(modeSelect.value==="bot" && current===BOT && !gameOver){
      setTimeout(botMove, 160);
    }
  }

  function reset(keepScores=true){
    board=Array(9).fill(null);
    current="X";
    gameOver=false;
    overlay.classList.remove("show");
    if(!keepScores) scores={X:0,O:0,D:0};
    statusText.textContent="X ist dran";
    setDotFor("X");
    render();
  }

  cells.forEach(cell=>{
    cell.addEventListener("click", ()=>{
      const i = Number(cell.dataset.i);
      if(modeSelect.value==="bot" && current===BOT) return;
      makeMove(i);
    });
  });

  modeSelect.addEventListener("change", ()=> reset(true));
  diffSelect.addEventListener("change", ()=> { if(modeSelect.value==="bot") reset(true); });
  newBtn.addEventListener("click", ()=> reset(true));
  resetScoresBtn.addEventListener("click", ()=> reset(false));

  // init
  setDotFor("X");
  updateMeta();
  reset(true);
})();

/* =========================
   SNAKE (mit Mobile D-Pad)
========================= */
(() => {
  const canvas = document.getElementById("snCanvas");
  const ctx = canvas.getContext("2d");

  const speedSel = document.getElementById("snSpeed");
  const sizeSel = document.getElementById("snSize");
  const newBtn = document.getElementById("snNew");
  const pauseBtn = document.getElementById("snPause");

  const wallBtn = document.getElementById("snWallBtn");
  const wallHint = document.getElementById("snWallHint");

  const statusText = document.getElementById("snStatus");
  const scoreEl = document.getElementById("snScore");

  const overlay = document.getElementById("snOverlay");
  const modalBig = document.getElementById("snModalBig");

  const dpad = document.getElementById("snDpad");

  const css = getComputedStyle(document.documentElement);
  function v(name){ return css.getPropertyValue(name).trim(); }
  const COLOR_SNAKE = v("--mint");
  const COLOR_HEAD  = v("--blue");
  const COLOR_FOOD  = v("--pink");
  const COLOR_GRID  = "rgba(20,48,74,0.22)";

  const GRID_LINE = 1.4;

  let N = 20;
  let tickMs = 120;
  let running = false;
  let paused = false;
  let score = 0;

  let wallsOn = false;
  let snake = [];
  let dir = {x:1,y:0};
  let nextDir = {x:1,y:0};
  let food = {x:10,y:10};

  let rafId = null;
  let lastTick = 0;

  function setCanvasSize(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function speedToMs(v){
    if(v==="slow") return 170;
    if(v==="fast") return 90;
    return 120;
  }

  function updateWallUI(){
    wallBtn.classList.toggle("on", wallsOn);
    wallHint.textContent = wallsOn ? "AN (Wand)" : "AUS (Wrap)";
    statusText.textContent = wallsOn ? "Wand-Modus" : "Wrap-Modus";
  }

  function randEmptyCell(){
    while(true){
      const x = Math.floor(Math.random()*N);
      const y = Math.floor(Math.random()*N);
      if(!snake.some(s=>s.x===x && s.y===y)) return {x,y};
    }
  }

  function resetGame(){
    N = parseInt(sizeSel.value, 10);
    tickMs = speedToMs(speedSel.value);

    score = 0;
    scoreEl.textContent = score;

    running = true;
    paused = false;
    pauseBtn.textContent = "Pause";
    overlay.classList.remove("show");

    const mid = Math.floor(N/2);
    snake = [{x:mid-1,y:mid},{x:mid,y:mid},{x:mid+1,y:mid}];
    dir = {x:1,y:0};
    nextDir = {x:1,y:0};

    food = randEmptyCell();
    statusText.textContent = "Los geht's!";
    canvas.focus();

    lastTick = 0;
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(loop);
    draw();
  }

  function togglePause(){
    if(!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? "Weiter" : "Pause";
    statusText.textContent = paused ? "Pausiert" : "Weiter!";
  }

  function gameOver(reason){
    running = false;
    paused = false;
    statusText.textContent = "Game Over";
    modalBig.textContent = "Punkte: " + score + (reason ? " ¬∑ " + reason : "");
    overlay.classList.add("show");
  }

  function setDirection(nx, ny){
    if(nx===-dir.x && ny===-dir.y) return;
    nextDir = {x:nx,y:ny};
  }

  function step(){
    dir = nextDir;

    const head = snake[snake.length-1];
    let newHead = {x: head.x + dir.x, y: head.y + dir.y};

    // FIX: im Wand-Modus ist 0..N-1 erlaubt. Nur <0 oder >=N ist Wand.
    if(wallsOn){
      if(newHead.x < 0 || newHead.x >= N || newHead.y < 0 || newHead.y >= N){
        gameOver("Wand ber√ºhrt!");
        return;
      }
    } else {
      if(newHead.x < 0) newHead.x = N-1;
      if(newHead.x >= N) newHead.x = 0;
      if(newHead.y < 0) newHead.y = N-1;
      if(newHead.y >= N) newHead.y = 0;
    }

    if(snake.some(s => s.x===newHead.x && s.y===newHead.y)){
      gameOver("In dich selbst!");
      return;
    }

    snake.push(newHead);

    if(newHead.x===food.x && newHead.y===food.y){
      score++;
      scoreEl.textContent = score;
      statusText.textContent = "Lecker!";
      food = randEmptyCell();
    } else {
      snake.shift();
    }
  }

  function draw(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const cell = Math.min(w,h) / N;
    const pad = cell * 0.10;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(210,235,255,0.55)";
    ctx.fillRect(0,0,w,h);

    ctx.lineWidth = GRID_LINE;
    ctx.strokeStyle = COLOR_GRID;
    for(let i=0;i<=N;i++){
      const x = i*cell, y=i*cell;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,N*cell); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(N*cell,y); ctx.stroke();
    }

    // food
    ctx.fillStyle = COLOR_FOOD;
    roundRect(food.x*cell+pad, food.y*cell+pad, cell-2*pad, cell-2*pad, Math.max(6,cell*0.22)); ctx.fill();

    // snake
    for(let i=0;i<snake.length;i++){
      const s = snake[i];
      const isHead = i===snake.length-1;
      ctx.fillStyle = isHead ? COLOR_HEAD : COLOR_SNAKE;
      roundRect(s.x*cell+pad, s.y*cell+pad, cell-2*pad, cell-2*pad, Math.max(6,cell*0.22)); ctx.fill();
    }

    if(wallsOn){
      ctx.strokeStyle = "rgba(20,48,74,0.32)";
      ctx.lineWidth = 6;
      ctx.strokeRect(3,3,N*cell-6,N*cell-6);
    }
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function loop(ts){
    if(!running) return;
    if(!paused){
      if(!lastTick) lastTick = ts;
      const dt = ts - lastTick;
      if(dt >= tickMs){
        lastTick = ts;
        step();
      }
    }
    draw();
    rafId = requestAnimationFrame(loop);
  }

  // Keyboard
  window.addEventListener("keydown", (e)=>{
    const k=e.key.toLowerCase();
    if(k==="arrowup"||k==="w"){ e.preventDefault(); setDirection(0,-1); }
    else if(k==="arrowdown"||k==="s"){ e.preventDefault(); setDirection(0,1); }
    else if(k==="arrowleft"||k==="a"){ e.preventDefault(); setDirection(-1,0); }
    else if(k==="arrowright"||k==="d"){ e.preventDefault(); setDirection(1,0); }
    else if(k===" "){ e.preventDefault(); togglePause(); }
  }, {passive:false});

  // Swipe (canvas only)
  let touchStart=null;
  canvas.addEventListener("touchstart",(e)=>{
    if(!e.touches||!e.touches[0]) return;
    touchStart={x:e.touches[0].clientX,y:e.touches[0].clientY};
  }, {passive:true});

  canvas.addEventListener("touchend",(e)=>{
    if(!touchStart) return;
    const t=(e.changedTouches&&e.changedTouches[0])?e.changedTouches[0]:null;
    if(!t) return;
    const dx=t.clientX-touchStart.x;
    const dy=t.clientY-touchStart.y;
    const ax=Math.abs(dx), ay=Math.abs(dy);
    const thr=18;
    if(ax<thr && ay<thr) return;
    if(ax>ay) setDirection(dx>0?1:-1,0);
    else setDirection(0,dy>0?1:-1);
    touchStart=null;
  }, {passive:true});

  // prevent scroll while touching canvas
  canvas.addEventListener("touchmove",(e)=>e.preventDefault(), {passive:false});

  // Buttons
  newBtn.addEventListener("click", resetGame);
  pauseBtn.addEventListener("click", togglePause);
  wallBtn.addEventListener("click", ()=>{ wallsOn=!wallsOn; updateWallUI(); draw(); });

  // Mobile D-Pad
  dpad.querySelectorAll("button").forEach(b=>{
    b.addEventListener("click", ()=>{
      const d=b.dataset.dir;
      if(d==="up") setDirection(0,-1);
      if(d==="down") setDirection(0,1);
      if(d==="left") setDirection(-1,0);
      if(d==="right") setDirection(1,0);
      if(d==="pause") togglePause();
      canvas.focus();
    });
  });

  // resize
  const ro = new ResizeObserver(()=>{ setCanvasSize(); draw(); });
  ro.observe(canvas.parentElement);

  // init
  setCanvasSize();
  updateWallUI();
  draw();
})();

/* =========================
   FLAPPY
========================= */
(() => {
  const canvas = document.getElementById("fbCanvas");
  const ctx = canvas.getContext("2d");

  const diffSel = document.getElementById("fbDiff");
  const modeSel = document.getElementById("fbMode");
  const startBtn = document.getElementById("fbStart");
  const resetBtn = document.getElementById("fbReset");

  const statusEl = document.getElementById("fbStatus");
  const scoreEl = document.getElementById("fbScore");

  const overlay = document.getElementById("fbOverlay");
  const modalBig = document.getElementById("fbModalBig");

  const css = getComputedStyle(document.documentElement);
  const BLUE = css.getPropertyValue("--blue").trim();
  const PINK = css.getPropertyValue("--pink").trim();
  const MINT = css.getPropertyValue("--mint").trim();

  let running=false;
  let score=0;

  let bird, pipes, t=0, last=0;
  let gravity=0.42, flap=-7.6;

  function setCanvasSize(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function config(){
    const diff = diffSel.value;
    const mode = modeSel.value;

    let speed = 2.6, gap = 160, spawn = 1500;
    if(diff==="easy"){ speed=2.1; gap=175; spawn=1600; }
    if(diff==="normal"){ speed=2.7; gap=160; spawn=1500; }
    if(diff==="hard"){ speed=3.4; gap=145; spawn=1400; }

    if(mode==="tight") gap -= 18;

    return {speed, gap, spawn};
  }

  function reset(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    bird = {x: w*0.28, y: h*0.5, vy: 0, r: 14};
    pipes = [];
    t = 0; last = 0;
    score = 0;
    scoreEl.textContent = "0";
    statusEl.textContent = "Bereit";
    overlay.classList.remove("show");
    running = false;
    draw();
  }

  function start(){
    reset();
    running = true;
    statusEl.textContent = "Flieg!";
    requestAnimationFrame(loop);
  }

  function addPipe(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const {gap} = config();

    const topMin = 60;
    const topMax = h - 60 - gap;
    const top = Math.random()*(topMax-topMin)+topMin;

    pipes.push({
      x: w + 40,
      w: 64,
      top: top,
      gap: gap,
      passed: false
    });
  }

  function flapNow(){
    if(!running) return;
    bird.vy = flap;
  }

  function hit(){
    running = false;
    statusEl.textContent = "Game Over";
    modalBig.textContent = "Score: " + score;
    overlay.classList.add("show");
  }

  function loop(ts){
    if(!running) return;
    if(!last) last = ts;
    const dt = Math.min(32, ts-last);
    last = ts;

    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const {speed, spawn} = config();

    t += dt;
    if(t > spawn){
      t = 0;
      addPipe();
    }

    // bird
    bird.vy += gravity;
    bird.y += bird.vy;

    // bounds
    if(bird.y - bird.r < 0 || bird.y + bird.r > h) { hit(); draw(); return; }

    // pipes move & collision
    for(const p of pipes){
      p.x -= speed;

      // collision AABB
      const bx = bird.x, by = bird.y, br = bird.r;

      // top pipe rect: x..x+w, 0..top
      // bottom: x..x+w, top+gap..h
      const inX = bx+br > p.x && bx-br < p.x+p.w;
      if(inX){
        const topHit = (by-br < p.top);
        const bottomHit = (by+br > p.top + p.gap);
        if(topHit || bottomHit){ hit(); draw(); return; }
      }

      // score
      if(!p.passed && p.x + p.w < bird.x){
        p.passed = true;
        score++;
        scoreEl.textContent = String(score);
      }
    }

    // cleanup
    pipes = pipes.filter(p => p.x + p.w > -80);

    draw();
    requestAnimationFrame(loop);
  }

  function draw(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);

    // bg
    ctx.fillStyle = "rgba(210,235,255,0.55)";
    ctx.fillRect(0,0,w,h);

    // pipes
    for(const p of pipes){
      ctx.fillStyle = "rgba(20,48,74,0.80)";
      ctx.fillRect(p.x, 0, p.w, p.top);
      ctx.fillRect(p.x, p.top + p.gap, p.w, h - (p.top+p.gap));

      ctx.fillStyle = "rgba(255,255,255,0.18)";
      ctx.fillRect(p.x+8, 0, 10, p.top);
      ctx.fillRect(p.x+8, p.top+p.gap, 10, h-(p.top+p.gap));
    }

    // bird
    ctx.fillStyle = PINK;
    ctx.beginPath();
    ctx.arc(bird?.x||w*0.28, bird?.y||h*0.5, bird?.r||14, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.beginPath();
    ctx.arc((bird?.x||w*0.28)-5, (bird?.y||h*0.5)-6, 5.5, 0, Math.PI*2);
    ctx.fill();

    // hint if not running
    if(!running){
      ctx.fillStyle = "rgba(20,48,74,0.75)";
      ctx.font = "700 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Dr√ºcke Start ‚Äì Tippen/Klicken/Space = Flap", 18, 26);
    }
  }

  function onAction(e){
    e.preventDefault();
    if(!running) return;
    flapNow();
  }

  canvas.addEventListener("pointerdown", onAction, {passive:false});
  canvas.addEventListener("touchmove", (e)=> e.preventDefault(), {passive:false});
  window.addEventListener("keydown", (e)=>{
    if(e.key===" "){
      e.preventDefault();
      if(!running) return;
      flapNow();
    }
  }, {passive:false});

  startBtn.addEventListener("click", start);
  resetBtn.addEventListener("click", reset);
  diffSel.addEventListener("change", ()=> { if(!running) draw(); });
  modeSel.addEventListener("change", ()=> { if(!running) draw(); });

  const ro = new ResizeObserver(()=>{ setCanvasSize(); draw(); });
  ro.observe(canvas.parentElement);

  setCanvasSize();
  reset();
})();

/* =========================
   MINIGOLF (25 Level + Pads + Circles + Movers)
========================= */
(() => {
  const canvas = document.getElementById("mgCanvas");
  const ctx = canvas.getContext("2d");

  const lvlEl = document.getElementById("mgLevel");
  const strokesEl = document.getElementById("mgStrokes");
  const bestEl = document.getElementById("mgBest");
  const toast = document.getElementById("mgToast");

  const btnReset = document.getElementById("mgReset");
  const btnPrev = document.getElementById("mgPrev");
  const btnNext = document.getElementById("mgNext");

  const css = getComputedStyle(document.documentElement);
  const BLUE = css.getPropertyValue("--blue").trim();
  const PINK = css.getPropertyValue("--pink").trim();
  const MINT = css.getPropertyValue("--mint").trim();

  const WORLD = { w: 1000, h: 600 };
  const BALL_R = 14;
  const HOLE_R = 18;

  const FRICTION = 0.986;
  const STOP_EPS = 0.16;
  const BASE_REST = 0.92;
  const MAX_POWER = 16;
  const MAX_SUB = 6;

  const rect=(x,y,w,h,opt={})=>({type:"rect",x,y,w,h,...opt});
  const circle=(x,y,r,opt={})=>({type:"circle",x,y,r,...opt});
  const pad=(x,y,w,h,boost=1.35)=>({type:"pad",x,y,w,h,boost});
  const mover=(x,y,w,h,toX,toY,period=2.2)=>({type:"mover",x,y,w,h,baseX:x,baseY:y,toX,toY,period,t:0});

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const len=(x,y)=>Math.sqrt(x*x+y*y);

  // 25 Level (kompakt, aber richtig)
  const levels = [
    { start:{x:140,y:300}, hole:{x:860,y:300}, walls:[rect(80,100,840,20),rect(80,480,840,20),rect(80,120,20,360),rect(900,120,20,360)], circles:[], pads:[], movers:[] },
    { start:{x:160,y:450}, hole:{x:840,y:150}, walls:[rect(80,100,840,20),rect(80,480,840,20),rect(80,120,20,360),rect(900,120,20,360),rect(320,240,360,20)], circles:[circle(520,360,26)], pads:[pad(220,420,110,18,1.35)], movers:[] },
    { start:{x:150,y:300}, hole:{x:850,y:300}, walls:[rect(80,100,840,20),rect(80,480,840,20),rect(80,120,20,360),rect(900,120,20,360),rect(520,120,20,240)], circles:[circle(650,380,22)], pads:[pad(140,140,120,18,1.30)], movers:[] },
    { start:{x:180,y:160}, hole:{x:820,y:440}, walls:[rect(80,100,840,20),rect(80,480,840,20),rect(80,120,20,360),rect(900,120,20,360),rect(300,180,20,260),rect(680,160,20,260)], circles:[circle(500,300,24)], pads:[], movers:[mover(470,120,60,18,470,190,1.8)] },
    { start:{x:160,y:300}, hole:{x:860,y:300}, walls:[rect(80,100,840,20),rect(80,480,840,20),rect(80,120,20,360),rect(900,120,20,360),rect(420,120,20,220),rect(560,260,20,220)], circles:[circle(700,210,20)], pads:[pad(820,140,70,18,1.38)], movers:[] },

    { start:{x:140,y:300}, hole:{x:860,y:300}, walls:[rect(70,90,860,20),rect(70,490,860,20),rect(70,110,20,380),rect(910,110,20,380),rect(240,110,20,260),rect(240,370,300,20),rect(600,230,20,260),rect(320,230,300,20)], circles:[circle(450,430,26)], pads:[pad(120,460,120,18,1.40)], movers:[mover(760,120,60,18,760,210,1.7)] },
    { start:{x:160,y:440}, hole:{x:850,y:160}, walls:[rect(70,90,860,20),rect(70,490,860,20),rect(70,110,20,380),rect(910,110,20,380),rect(360,110,20,240),rect(360,370,20,120),rect(650,90,20,260),rect(650,370,20,140),rect(360,340,290,20)], circles:[circle(520,190,22),circle(520,420,22)], pads:[pad(820,460,90,18,1.36)], movers:[] },
    { start:{x:150,y:300}, hole:{x:850,y:300}, walls:[rect(70,90,860,20),rect(70,490,860,20),rect(70,110,20,380),rect(910,110,20,380),rect(300,180,20,260),rect(680,160,20,260),rect(300,160,200,20),rect(480,420,220,20)], circles:[circle(560,300,26)], pads:[pad(120,140,120,18,1.32)], movers:[mover(520,240,70,18,610,240,2.2)] },
    { start:{x:150,y:150}, hole:{x:860,y:450}, walls:[rect(70,90,860,20),rect(70,490,860,20),rect(70,110,20,380),rect(910,110,20,380),rect(280,110,20,220),rect(280,350,380,20),rect(720,260,20,230),rect(420,260,300,20)], circles:[circle(420,420,22)], pads:[pad(820,140,90,18,1.40)], movers:[] },
    { start:{x:160,y:300}, hole:{x:860,y:300}, walls:[rect(70,90,860,20),rect(70,490,860,20),rect(70,110,20,380),rect(910,110,20,380),rect(260,110,20,290),rect(260,420,360,20),rect(640,190,20,300),rect(360,190,280,20)], circles:[circle(740,420,24)], pads:[pad(120,460,140,18,1.36)], movers:[mover(520,110,60,18,520,170,1.6)] },

    { start:{x:140,y:300}, hole:{x:860,y:300}, walls:[rect(60,80,880,20),rect(60,500,880,20),rect(60,100,20,400),rect(920,100,20,400),rect(200,100,20,320),rect(200,440,520,20),rect(360,180,20,340),rect(520,100,20,320),rect(680,180,20,340),rect(520,420,220,20)], circles:[circle(780,140,18),circle(780,460,18)], pads:[pad(820,290,90,18,1.42)], movers:[] },
    { start:{x:140,y:460}, hole:{x:860,y:140}, walls:[rect(60,80,880,20),rect(60,500,880,20),rect(60,100,20,400),rect(920,100,20,400),rect(240,140,520,20),rect(240,140,20,320),rect(400,220,360,20),rect(740,220,20,220),rect(400,420,360,20),rect(400,260,20,160)], circles:[circle(700,380,24)], pads:[pad(120,140,130,18,1.35)], movers:[mover(600,300,80,18,600,360,1.9)] },
    { start:{x:150,y:300}, hole:{x:850,y:300}, walls:[rect(60,80,880,20),rect(60,500,880,20),rect(60,100,20,400),rect(920,100,20,400),rect(260,100,20,280),rect(260,400,240,20),rect(520,180,20,340),rect(360,180,160,20),rect(700,100,20,280),rect(540,400,160,20)], circles:[circle(440,330,22),circle(620,330,22)], pads:[pad(820,460,100,18,1.40)], movers:[] },
    { start:{x:160,y:150}, hole:{x:860,y:450}, walls:[rect(60,80,880,20),rect(60,500,880,20),rect(60,100,20,400),rect(920,100,20,400),rect(260,160,420,20),rect(260,160,20,300),rect(420,260,420,20),rect(840,260,20,200),rect(420,420,20,100)], circles:[circle(560,210,24)], pads:[pad(120,460,140,18,1.34)], movers:[mover(740,420,80,18,820,420,2.0)] },
    { start:{x:160,y:300}, hole:{x:860,y:300}, walls:[rect(60,80,880,20),rect(60,500,880,20),rect(60,100,20,400),rect(920,100,20,400),rect(260,100,20,340),rect(260,460,420,20),rect(420,140,20,340),rect(580,100,20,340),rect(740,140,20,340),rect(420,140,340,20)], circles:[circle(500,420,22)], pads:[pad(820,140,90,18,1.45)], movers:[mover(500,260,80,18,580,260,1.7)] },

    { start:{x:120,y:300}, hole:{x:880,y:300}, walls:[rect(50,70,900,20),rect(50,510,900,20),rect(50,90,20,420),rect(930,90,20,420),rect(170,90,20,340),rect(170,450,620,20),rect(310,150,20,360),rect(450,90,20,340),rect(590,150,20,360),rect(730,90,20,340),rect(310,150,460,20)], circles:[circle(860,160,18),circle(860,440,18)], pads:[pad(110,140,140,18,1.42)], movers:[mover(520,430,90,18,520,350,2.3)] },
    { start:{x:120,y:460}, hole:{x:880,y:140}, walls:[rect(50,70,900,20),rect(50,510,900,20),rect(50,90,20,420),rect(930,90,20,420),rect(210,120,640,20),rect(210,120,20,350),rect(350,200,500,20),rect(850,200,20,240),rect(350,420,520,20),rect(350,240,20,180)], circles:[circle(620,320,26)], pads:[pad(820,460,100,18,1.38)], movers:[mover(620,120,70,18,760,120,2.4)] },
    { start:{x:120,y:300}, hole:{x:880,y:300}, walls:[rect(50,70,900,20),rect(50,510,900,20),rect(50,90,20,420),rect(930,90,20,420),rect(210,90,20,300),rect(210,410,520,20),rect(370,150,20,360),rect(530,90,20,300),rect(690,150,20,360),rect(530,430,180,20)], circles:[circle(780,300,20)], pads:[pad(110,460,150,18,1.44)], movers:[mover(610,260,80,18,610,340,1.8)] },
    { start:{x:120,y:140}, hole:{x:880,y:460}, walls:[rect(50,70,900,20),rect(50,510,900,20),rect(50,90,20,420),rect(930,90,20,420),rect(230,140,520,20),rect(230,140,20,320),rect(390,240,540,20),rect(870,240,20,250),rect(390,470,20,40),rect(550,140,20,220)], circles:[circle(720,420,24),circle(720,320,20)], pads:[pad(820,140,100,18,1.40)], movers:[] },
    { start:{x:120,y:300}, hole:{x:880,y:300}, walls:[rect(50,70,900,20),rect(50,510,900,20),rect(50,90,20,420),rect(930,90,20,420),rect(230,90,20,360),rect(230,470,520,20),rect(410,130,20,380),rect(590,90,20,360),rect(770,130,20,380),rect(410,130,380,20)], circles:[circle(860,300,16)], pads:[pad(110,140,150,18,1.48)], movers:[mover(500,420,110,18,650,420,2.1)] },

    { start:{x:110,y:300}, hole:{x:890,y:300}, walls:[rect(40,60,920,20),rect(40,520,920,20),rect(40,80,20,440),rect(940,80,20,440),rect(180,80,20,380),rect(180,480,660,20),rect(320,140,20,400),rect(460,80,20,380),rect(600,140,20,400),rect(740,80,20,380),rect(320,140,480,20),rect(460,440,480,20)], circles:[circle(820,300,22)], pads:[pad(110,140,160,18,1.52)], movers:[mover(760,260,90,18,760,360,1.6)] },
    { start:{x:110,y:460}, hole:{x:890,y:140}, walls:[rect(40,60,920,20),rect(40,520,920,20),rect(40,80,20,440),rect(940,80,20,440),rect(220,120,620,20),rect(220,120,20,360),rect(360,200,500,20),rect(860,200,20,260),rect(360,460,520,20),rect(360,240,20,220),rect(500,120,20,200)], circles:[circle(650,410,24),circle(650,300,20)], pads:[pad(820,460,110,18,1.44)], movers:[mover(650,160,80,18,780,160,2.0)] },
    { start:{x:110,y:300}, hole:{x:890,y:300}, walls:[rect(40,60,920,20),rect(40,520,920,20),rect(40,80,20,440),rect(940,80,20,440),rect(220,80,20,340),rect(220,440,580,20),rect(380,140,20,400),rect(540,80,20,340),rect(700,140,20,400),rect(540,460,180,20),rect(700,140,220,20)], circles:[circle(820,240,18),circle(820,360,18)], pads:[pad(110,460,170,18,1.50)], movers:[mover(600,260,90,18,600,340,1.35)] },
    { start:{x:110,y:140}, hole:{x:890,y:460}, walls:[rect(40,60,920,20),rect(40,520,920,20),rect(40,80,20,440),rect(940,80,20,440),rect(240,140,540,20),rect(240,140,20,340),rect(400,240,560,20),rect(880,240,20,260),rect(560,140,20,240),rect(720,320,220,20)], circles:[circle(720,420,22)], pads:[pad(820,140,120,18,1.52)], movers:[mover(720,340,90,18,820,340,1.55)] },
    { start:{x:110,y:300}, hole:{x:890,y:300}, walls:[rect(40,60,920,20),rect(40,520,920,20),rect(40,80,20,440),rect(940,80,20,440),rect(240,80,20,380),rect(240,480,560,20),rect(420,120,20,400),rect(600,80,20,380),rect(780,120,20,400),rect(420,120,380,20),rect(420,420,380,20),rect(800,260,140,20)], circles:[circle(860,220,18),circle(860,380,18)], pads:[pad(110,140,180,18,1.58),pad(110,460,180,18,1.58)], movers:[mover(720,260,90,18,720,360,1.1),mover(520,260,90,18,520,360,1.25)] },
  ];

  // state
  let idx=0, strokes=0;
  const ball={x:0,y:0,vx:0,vy:0};
  const hole={x:0,y:0};

  let dragging=false, dragStart=null, dragNow=null;

  const bestKey=(i)=>`mg_best_${i}`;
  const loadBest=(i)=>{ const v=localStorage.getItem(bestKey(i)); return v?Number(v):null; };
  const saveBest=(i,val)=> localStorage.setItem(bestKey(i), String(val));

  function ui(){
    lvlEl.textContent=String(idx+1);
    strokesEl.textContent=String(strokes);
    const b=loadBest(idx);
    bestEl.textContent=(b==null?"‚Äì":String(b));
  }

  function toastShow(t){
    if(!t){ toast.classList.remove("show"); return; }
    toast.textContent=t;
    toast.classList.add("show");
    clearTimeout(toastShow._t);
    toastShow._t=setTimeout(()=>toast.classList.remove("show"), 1200);
  }

  function setLevel(i){
    idx=clamp(i,0,levels.length-1);
    const L=levels[idx];
    ball.x=L.start.x; ball.y=L.start.y; ball.vx=0; ball.vy=0;
    hole.x=L.hole.x; hole.y=L.hole.y;
    (L.movers||[]).forEach(m=>{ m.t=0; m.x=m.baseX; m.y=m.baseY; });
    strokes=0;
    ui();
    toastShow("");
    draw();
  }

  function resize(){
    const rect=canvas.getBoundingClientRect();
    const dpr=Math.max(1, window.devicePixelRatio||1);
    canvas.width=Math.floor(rect.width*dpr);
    canvas.height=Math.floor(rect.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  const ro=new ResizeObserver(()=>{ resize(); draw(); });
  ro.observe(canvas.parentElement);

  function getPos(e){
    const rect=canvas.getBoundingClientRect();
    const x=(e.clientX-rect.left)*(WORLD.w/rect.width);
    const y=(e.clientY-rect.top)*(WORLD.h/rect.height);
    return {x,y};
  }
  function stopped(){ return Math.abs(ball.vx)<STOP_EPS && Math.abs(ball.vy)<STOP_EPS; }

  function down(e){
    e.preventDefault();
    if(!stopped()) return;
    const p=getPos(e);
    const dx=p.x-ball.x, dy=p.y-ball.y;
    if(dx*dx+dy*dy <= (BALL_R*1.6)*(BALL_R*1.6)){
      dragging=true; dragStart={x:ball.x,y:ball.y}; dragNow=p;
    }
  }
  function move(e){
    if(!dragging) return;
    e.preventDefault();
    dragNow=getPos(e);
  }
  function up(e){
    if(!dragging) return;
    e.preventDefault();
    const vx=(dragStart.x-dragNow.x)*0.065;
    const vy=(dragStart.y-dragNow.y)*0.065;
    const mag=len(vx,vy);
    if(mag>0.1){
      const scale=Math.min(MAX_POWER,mag)/mag;
      ball.vx=vx*scale; ball.vy=vy*scale;
      strokes++; ui();
    }
    dragging=false; dragStart=null; dragNow=null;
  }

  canvas.addEventListener("pointerdown", down, {passive:false});
  canvas.addEventListener("pointermove", move, {passive:false});
  window.addEventListener("pointerup", up, {passive:false});
  canvas.addEventListener("touchmove",(e)=>e.preventDefault(),{passive:false});

  function resolveCR(b,r,rest){
    const cx=clamp(b.x,r.x,r.x+r.w);
    const cy=clamp(b.y,r.y,r.y+r.h);
    const dx=b.x-cx, dy=b.y-cy;
    const d2=dx*dx+dy*dy;
    if(d2<=BALL_R*BALL_R){
      const d=Math.max(0.0001,Math.sqrt(d2));
      const nx=dx/d, ny=dy/d;
      const overlap=BALL_R-d;
      b.x+=nx*overlap; b.y+=ny*overlap;
      const dot=b.vx*nx+b.vy*ny;
      b.vx=(b.vx-2*dot*nx)*rest;
      b.vy=(b.vy-2*dot*ny)*rest;
      return true;
    }
    return false;
  }
  function resolveCC(b,c,rest){
    const dx=b.x-c.x, dy=b.y-c.y;
    const d=Math.max(0.0001,Math.sqrt(dx*dx+dy*dy));
    const min=BALL_R+c.r;
    if(d<min){
      const nx=dx/d, ny=dy/d;
      const overlap=min-d;
      b.x+=nx*overlap; b.y+=ny*overlap;
      const dot=b.vx*nx+b.vy*ny;
      b.vx=(b.vx-2*dot*nx)*rest;
      b.vy=(b.vy-2*dot*ny)*rest;
      return true;
    }
    return false;
  }
  function inHole(){
    const dx=ball.x-hole.x, dy=ball.y-hole.y;
    const d=Math.sqrt(dx*dx+dy*dy);
    const sp=Math.sqrt(ball.vx*ball.vx+ball.vy*ball.vy);
    return d<HOLE_R*0.72 && sp<2.2;
  }

  function updateMovers(L,dt){
    for(const m of (L.movers||[])){
      m.t+=dt;
      const a=(Math.sin((m.t/m.period)*Math.PI*2)+1)*0.5;
      m.x=m.baseX+(m.toX-m.baseX)*a;
      m.y=m.baseY+(m.toY-m.baseY)*a;
    }
  }

  let last=0;
  function loop(ts){
    if(!last) last=ts;
    const dt=Math.min(0.033,(ts-last)/1000);
    last=ts;

    const L=levels[idx];
    updateMovers(L,dt);

    const sp=len(ball.vx,ball.vy);
    const steps=clamp(Math.ceil(sp/6),1,MAX_SUB);

    for(let s=0;s<steps;s++){
      ball.x+=ball.vx; ball.y+=ball.vy;
      ball.vx*=FRICTION; ball.vy*=FRICTION;
      if(Math.abs(ball.vx)<STOP_EPS) ball.vx=0;
      if(Math.abs(ball.vy)<STOP_EPS) ball.vy=0;

      ball.x=clamp(ball.x,BALL_R+8,WORLD.w-BALL_R-8);
      ball.y=clamp(ball.y,BALL_R+8,WORLD.h-BALL_R-8);

      for(const w of (L.walls||[])) resolveCR(ball,w,BASE_REST);
      for(const m of (L.movers||[])) resolveCR(ball,m,BASE_REST);
      for(const c of (L.circles||[])) resolveCC(ball,c,BASE_REST);
      for(const p of (L.pads||[])){
        const rest=clamp(BASE_REST*p.boost,0.9,1.25);
        if(resolveCR(ball,p,rest)){ ball.vx*=1.03; ball.vy*=1.03; }
      }

      if(inHole()){
        const old=loadBest(idx);
        if(old==null || strokes<old) saveBest(idx,strokes);
        ui();
        toastShow("Level geschafft! üéâ");
        ball.vx=0; ball.vy=0; ball.x=hole.x; ball.y=hole.y;
        setTimeout(()=>{ if(idx<levels.length-1) setLevel(idx+1); else toastShow("Alle Level geschafft! üèÜ"); }, 650);
        break;
      }
    }

    draw();
    requestAnimationFrame(loop);
  }

  function draw(){
    const rect=canvas.getBoundingClientRect();
    const sx=rect.width/WORLD.w, sy=rect.height/WORLD.h;

    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,rect.width,rect.height);
    ctx.restore();

    ctx.save();
    ctx.scale(sx,sy);

    ctx.fillStyle="rgba(255,255,255,0.78)";
    ctx.fillRect(0,0,WORLD.w,WORLD.h);

    ctx.strokeStyle="rgba(20,48,74,0.18)";
    ctx.lineWidth=6;
    ctx.strokeRect(6,6,WORLD.w-12,WORLD.h-12);

    const L=levels[idx];

    ctx.fillStyle="rgba(20,48,74,0.75)";
    for(const w of (L.walls||[])) ctx.fillRect(w.x,w.y,w.w,w.h);

    for(const m of (L.movers||[])){
      ctx.fillStyle="rgba(47,121,255,0.75)";
      ctx.fillRect(m.x,m.y,m.w,m.h);
      ctx.fillStyle="rgba(255,255,255,0.35)";
      ctx.fillRect(m.x+6,m.y+6,m.w-12,m.h-12);
    }

    for(const p of (L.pads||[])){
      ctx.fillStyle=MINT;
      ctx.fillRect(p.x,p.y,p.w,p.h);
      ctx.strokeStyle="rgba(255,255,255,0.65)";
      ctx.lineWidth=4;
      ctx.strokeRect(p.x+2,p.y+2,p.w-4,p.h-4);
    }

    for(const c of (L.circles||[])){
      ctx.fillStyle="rgba(255,95,149,0.85)";
      ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle="rgba(255,255,255,0.35)";
      ctx.beginPath(); ctx.arc(c.x-6,c.y-6,Math.max(6,c.r*0.35),0,Math.PI*2); ctx.fill();
    }

    ctx.fillStyle="rgba(20,48,74,0.92)";
    ctx.beginPath(); ctx.arc(hole.x,hole.y,HOLE_R,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(255,255,255,0.85)";
    ctx.beginPath(); ctx.arc(hole.x-6,hole.y-6,HOLE_R*0.33,0,Math.PI*2); ctx.fill();

    if(dragging && dragStart && dragNow){
      const dx=dragStart.x-dragNow.x;
      const dy=dragStart.y-dragNow.y;
      const mag=Math.sqrt(dx*dx+dy*dy);
      const pow=Math.min(1,mag/220);
      ctx.strokeStyle=`rgba(47,121,255,${0.25+0.55*pow})`;
      ctx.lineWidth=8; ctx.lineCap="round";
      ctx.beginPath(); ctx.moveTo(ball.x,ball.y); ctx.lineTo(ball.x+dx*0.7, ball.y+dy*0.7); ctx.stroke();
      ctx.fillStyle=`rgba(47,121,255,${0.18+0.42*pow})`;
      ctx.beginPath(); ctx.arc(ball.x+dx*0.7, ball.y+dy*0.7, 12, 0, Math.PI*2); ctx.fill();
    }

    ctx.fillStyle=PINK;
    ctx.beginPath(); ctx.arc(ball.x,ball.y,BALL_R,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(255,255,255,0.85)";
    ctx.beginPath(); ctx.arc(ball.x-5,ball.y-6,BALL_R*0.32,0,Math.PI*2); ctx.fill();

    ctx.restore();
  }

  btnReset.addEventListener("click", ()=> setLevel(idx));
  btnPrev.addEventListener("click", ()=> setLevel(idx-1));
  btnNext.addEventListener("click", ()=> setLevel(idx+1));

  resize();
  setLevel(0);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
