<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>GamePortal</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body class="light">
  <!-- NAVBAR -->
  <nav class="navbar">
    <div class="logo" role="button" tabindex="0" id="logoHome">GamePortal</div>

    <div class="theme-switch" aria-label="Theme Switch">
      <span>Light</span>
      <div id="modeToggle" class="switch" role="button" tabindex="0" aria-label="Light/Dark umschalten">
        <div class="knob"></div>
      </div>
      <span>Dark</span>
    </div>
  </nav>

  <!-- HOME -->
  <section class="screen show" id="screen-home" aria-label="Homepage">
    <header class="hero">
      <h1>Game Portal</h1>
      <p>Wähle ein Spiel aus und starte sofort</p>
    </header>

    <main class="games">
      <div class="game-card" data-open="ttt">
        <h2>Spiel 1: Tic Tac Toe</h2>
        <p>2 Spieler oder gegen Bot (leicht/mittel/schwer)</p>
      </div>

      <div class="game-card" data-open="snake">
        <h2>Spiel 2: Snake</h2>
        <p>Wand-Modus + Handy-Steuerung mit Pfeilen</p>
      </div>

      <div class="game-card" data-open="flappy">
        <h2>Spiel 3: Flappy Bird</h2>
        <p>Start-Button + Schwierigkeit</p>
      </div>

      <div class="game-card" data-open="connect4">
        <h2>Spiel 4: 4 Gewinnt</h2>
        <p>Falling Physics + gegen Bot</p>
      </div>

      <a class="game-card link-card" href="http://massi2912.github.io/Coockie/" target="_blank" rel="noreferrer">
        <h2>Extra: Cookie Clicker</h2>
        <p>Öffnet externe Seite</p>
      </a>
    </main>
  </section>

  <!-- TTT -->
  <section class="screen" id="screen-ttt" aria-label="Tic Tac Toe">
    <header class="topbar">
      <button class="btn ghost" data-home type="button">Home</button>
      <div class="topTitle">
        <h2>Tic Tac Toe</h2>
        <p>Babyblau Theme • mobil stabil</p>
      </div>
      <div class="topRight"></div>
    </header>

    <div class="appGrid">
      <aside class="panel">
        <div class="panelBox">
          <div class="row2">
            <div class="field">
              <label for="tttMode">Modus</label>
              <select id="tttMode">
                <option value="pvp">2 Spieler</option>
                <option value="bot">Gegen Bot</option>
              </select>
            </div>

            <div class="field">
              <label for="tttDiff">Schwierigkeit</label>
              <select id="tttDiff">
                <option value="easy">Leicht</option>
                <option value="medium" selected>Mittel</option>
                <option value="hard">Schwer</option>
              </select>
            </div>
          </div>

          <div class="actions">
            <button class="btn primary" id="tttNew">Neues Spiel</button>
            <button class="btn" id="tttResetScores">Punkte zurücksetzen</button>
          </div>
        </div>

        <div class="statusCard">
          <div class="statusLeft">
            <span class="dot" id="tttDot"></span>
            <span id="tttStatus">X ist dran</span>
          </div>
          <div class="meta" id="tttMeta">2 Spieler</div>
        </div>

        <div class="scoreCard">
          <div class="pills">
            <span class="pill">X: <strong id="tttScoreX">0</strong></span>
            <span class="pill">O: <strong id="tttScoreO">0</strong></span>
            <span class="pill">Remis: <strong id="tttScoreD">0</strong></span>
          </div>
          <div class="meta">Schwer spielt perfekt.</div>
        </div>
      </aside>

      <main class="boardArea">
        <div class="boardWrap">
          <div class="board" id="tttBoard" aria-label="TTT Spielbrett">
            <button class="cell" data-i="0" aria-label="Feld 1"></button>
            <button class="cell" data-i="1" aria-label="Feld 2"></button>
            <button class="cell" data-i="2" aria-label="Feld 3"></button>
            <button class="cell" data-i="3" aria-label="Feld 4"></button>
            <button class="cell" data-i="4" aria-label="Feld 5"></button>
            <button class="cell" data-i="5" aria-label="Feld 6"></button>
            <button class="cell" data-i="6" aria-label="Feld 7"></button>
            <button class="cell" data-i="7" aria-label="Feld 8"></button>
            <button class="cell" data-i="8" aria-label="Feld 9"></button>
          </div>
        </div>

        <div class="overlay" id="tttOverlay" aria-live="polite">
          <div class="modal">
            <p class="modalTitle" id="tttModalTitle">Gewinner</p>
            <p class="modalBig" id="tttModalBig">—</p>
            <p class="modalSub">Neues Spiel starten</p>
          </div>
        </div>
      </main>
    </div>
  </section>

  <!-- SNAKE -->
  <section class="screen" id="screen-snake" aria-label="Snake">
    <header class="topbar">
      <button class="btn ghost" data-home type="button">Home</button>
      <div class="topTitle">
        <h2>Snake</h2>
        <p>WASD/Pfeile (Desktop) • Swipe + Pfeile (Mobile)</p>
      </div>
      <div class="topRight"></div>
    </header>

    <div class="appGrid">
      <aside class="panel">
        <div class="panelBox">
          <div class="row2">
            <div class="field">
              <label for="snSpeed">Geschwindigkeit</label>
              <select id="snSpeed">
                <option value="slow">Langsam</option>
                <option value="normal" selected>Normal</option>
                <option value="fast">Schnell</option>
              </select>
            </div>
            <div class="field">
              <label for="snSize">Spielfeld</label>
              <select id="snSize">
                <option value="16">Einfach (16×16)</option>
                <option value="20" selected>Normal (20×20)</option>
                <option value="26">Groß (26×26)</option>
              </select>
            </div>
          </div>

          <div class="actions">
            <button class="btn wallToggle" id="snWallBtn" type="button">
              <span class="toggleLeft">
                <span class="toggleTitle">Wand-Modus</span>
                <span class="toggleHint" id="snWallHint">AUS (Wrap)</span>
              </span>
              <span class="miniSwitch" aria-hidden="true"><span class="miniKnob"></span></span>
            </button>

            <button class="btn primary" id="snNew">Neues Spiel</button>
            <button class="btn" id="snPause">Pause</button>
          </div>
        </div>

        <div class="statusCard">
          <div class="statusLeft">
            <span class="dot mint"></span>
            <span id="snStatus">Bereit</span>
          </div>
          <div class="scoreBig">
            <span class="scoreLabel">Punkte</span>
            <span class="scoreNumber" id="snScore">0</span>
          </div>
        </div>

        <div class="helpCard">
          <div><strong>Desktop:</strong> WASD / Pfeile • <strong>Pause:</strong> Leertaste</div>
          <div><strong>Handy:</strong> Swipe oder Pfeile unten</div>
        </div>
      </aside>

      <main class="boardArea">
        <div class="boardWrap">
          <div class="canvasShell">
            <canvas id="snCanvas" aria-label="Snake Spielfeld" tabindex="0"></canvas>
          </div>
        </div>

        <div class="overlay" id="snOverlay" aria-live="polite">
          <div class="modal">
            <p class="modalTitle">Game Over</p>
            <p class="modalBig" id="snModalBig">Punkte: 0</p>
            <p class="modalSub">Drücke „Neues Spiel“</p>
          </div>
        </div>

        <!-- Mobile D-Pad -->
        <div class="dpad" id="snDpad" aria-label="Mobile Steuerung">
          <button class="dbtn up" data-dir="up" type="button">▲</button>
          <button class="dbtn left" data-dir="left" type="button">◀</button>
          <button class="dbtn mid" data-dir="pause" type="button">⏯</button>
          <button class="dbtn right" data-dir="right" type="button">▶</button>
          <button class="dbtn down" data-dir="down" type="button">▼</button>
        </div>
      </main>
    </div>
  </section>

  <!-- FLAPPY -->
  <section class="screen" id="screen-flappy" aria-label="Flappy Bird">
    <header class="topbar">
      <button class="btn ghost" data-home type="button">Home</button>
      <div class="topTitle">
        <h2>Flappy Bird</h2>
        <p>Tippen/Klicken zum Fliegen • Start-Button • Schwierigkeit</p>
      </div>
      <div class="topRight"></div>
    </header>

    <div class="appGrid">
      <aside class="panel">
        <div class="panelBox">
          <div class="row2">
            <div class="field">
              <label for="fbDiff">Schwierigkeit</label>
              <select id="fbDiff">
                <option value="easy">Leicht (langsamer)</option>
                <option value="normal" selected>Normal</option>
                <option value="hard">Schwer (schneller)</option>
              </select>
            </div>
            <div class="field">
              <label for="fbMode">Modus</label>
              <select id="fbMode">
                <option value="classic" selected>Klassisch</option>
                <option value="tight">Enger</option>
              </select>
            </div>
          </div>

          <div class="actions">
            <button class="btn primary" id="fbStart">Start</button>
            <button class="btn" id="fbReset">Reset</button>
          </div>
        </div>

        <div class="statusCard">
          <div class="statusLeft">
            <span class="dot pink"></span>
            <span id="fbStatus">Bereit</span>
          </div>
          <div class="scoreBig">
            <span class="scoreLabel">Score</span>
            <span class="scoreNumber" id="fbScore">0</span>
          </div>
        </div>

        <div class="helpCard">
          <div><strong>Steuerung:</strong> Tippen/Klicken oder Leertaste</div>
          <div><strong>Tipp:</strong> Ruhig bleiben – kleine Flaps!</div>
        </div>
      </aside>

      <main class="boardArea">
        <div class="boardWrap">
          <div class="canvasShell">
            <canvas id="fbCanvas" aria-label="Flappy Spiel" tabindex="0"></canvas>
          </div>
        </div>

        <div class="overlay" id="fbOverlay" aria-live="polite">
          <div class="modal">
            <p class="modalTitle">Game Over</p>
            <p class="modalBig" id="fbModalBig">Score: 0</p>
            <p class="modalSub">Drücke „Start“</p>
          </div>
        </div>
      </main>
    </div>
  </section>

  <!-- CONNECT 4 -->
  <section class="screen" id="screen-connect4" aria-label="4 Gewinnt">
    <header class="topbar">
      <button class="btn ghost" data-home type="button">Home</button>
      <div class="topTitle">
        <h2>4 Gewinnt</h2>
        <p>Tippe auf eine Spalte • Chips fallen runter • gegen Bot</p>
      </div>
      <div class="topRight"></div>
    </header>

    <div class="appGrid">
      <aside class="panel">
        <div class="panelBox">
          <div class="row2">
            <div class="field">
              <label for="c4Mode">Modus</label>
              <select id="c4Mode">
                <option value="pvp">2 Spieler</option>
                <option value="bot" selected>Gegen Bot</option>
              </select>
            </div>
            <div class="field">
              <label for="c4Diff">Bot</label>
              <select id="c4Diff">
                <option value="easy" selected>Leicht</option>
                <option value="medium">Mittel</option>
                <option value="hard">Schwer</option>
              </select>
            </div>
          </div>

          <div class="actions">
            <button class="btn primary" id="c4New">Neues Spiel</button>
            <button class="btn" id="c4Undo">Undo</button>
          </div>
        </div>

        <div class="statusCard">
          <div class="statusLeft">
            <span class="dot" id="c4Dot"></span>
            <span id="c4Status">Rot ist dran</span>
          </div>
          <div class="meta" id="c4Meta">Gegen Bot</div>
        </div>

        <div class="helpCard">
          <div><strong>Goal:</strong> 4 in einer Reihe (horizontal/vertikal/diagonal)</div>
          <div><strong>Mobile:</strong> Tippen auf Spalte</div>
        </div>
      </aside>

      <main class="boardArea">
        <div class="boardWrap">
          <div class="canvasShell c4">
            <canvas id="c4Canvas" aria-label="4 Gewinnt Spielfeld"></canvas>
          </div>
        </div>

        <div class="overlay" id="c4Overlay" aria-live="polite">
          <div class="modal">
            <p class="modalTitle" id="c4ModalTitle">Ergebnis</p>
            <p class="modalBig" id="c4ModalBig">—</p>
            <p class="modalSub">Drücke „Neues Spiel“</p>
          </div>
        </div>
      </main>
    </div>
  </section>

<script>
/* =========================
   PORTAL NAV + THEME
========================= */
const body = document.body;
const toggle = document.getElementById("modeToggle");
const logoHome = document.getElementById("logoHome");

function setTheme(theme){
  body.classList.toggle("dark", theme === "dark");
  body.classList.toggle("light", theme !== "dark");
  toggle.classList.toggle("active", theme === "dark");
  localStorage.setItem("gp_theme", theme);
}
setTheme(localStorage.getItem("gp_theme") || "light");

toggle.addEventListener("click", ()=> setTheme(body.classList.contains("dark") ? "light" : "dark"));
toggle.addEventListener("keydown", (e)=> { if(e.key==="Enter"||e.key===" "){ e.preventDefault(); toggle.click(); }});

function showScreen(name){
  document.querySelectorAll(".screen").forEach(s => s.classList.remove("show"));
  document.getElementById("screen-" + name).classList.add("show");
  window.scrollTo({top:0, behavior:"instant"});
}
document.querySelectorAll("[data-home]").forEach(b => b.addEventListener("click", ()=> showScreen("home")));
logoHome.addEventListener("click", ()=> showScreen("home"));
logoHome.addEventListener("keydown", (e)=> { if(e.key==="Enter"||e.key===" "){ e.preventDefault(); showScreen("home"); }});

document.querySelectorAll("[data-open]").forEach(card => {
  card.addEventListener("click", ()=> {
    const target = card.getAttribute("data-open");
    showScreen(target);
    if(target==="snake") document.getElementById("snCanvas").focus();
    if(target==="flappy") document.getElementById("fbCanvas").focus();
  });
});

/* =========================
   TTT (dein bewährter Bot)
========================= */
(() => {
  const cells = Array.from(document.querySelectorAll("#tttBoard .cell"));
  const statusText = document.getElementById("tttStatus");
  const metaText = document.getElementById("tttMeta");
  const modeSelect = document.getElementById("tttMode");
  const diffSelect = document.getElementById("tttDiff");
  const newBtn = document.getElementById("tttNew");
  const resetScoresBtn = document.getElementById("tttResetScores");
  const dot = document.getElementById("tttDot");

  const overlay = document.getElementById("tttOverlay");
  const modalTitle = document.getElementById("tttModalTitle");
  const modalBig = document.getElementById("tttModalBig");

  const scoreXEl = document.getElementById("tttScoreX");
  const scoreOEl = document.getElementById("tttScoreO");
  const scoreDEl = document.getElementById("tttScoreD");

  const HUMAN = "X";
  const BOT = "O";
  const WIN_LINES = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
  ];

  let board = Array(9).fill(null);
  let current = "X";
  let gameOver = false;
  let scores = {X:0, O:0, D:0};

  function setDotFor(p){
    dot.classList.remove("x","o");
    if(p==="X") dot.classList.add("x");
    else if(p==="O") dot.classList.add("o");
  }

  function updateMeta(){
    const isBot = modeSelect.value === "bot";
    diffSelect.disabled = !isBot;
    const d = diffSelect.value;
    const diffLabel = d==="easy"?"Leicht":d==="medium"?"Mittel":"Schwer";
    metaText.textContent = isBot ? ("Gegen Bot · " + diffLabel) : "2 Spieler";
  }

  function checkWinner(b){
    for(const line of WIN_LINES){
      const [a,b1,c] = line;
      if(b[a] && b[a]===b[b1] && b[a]===b[c]) return {winner:b[a], line};
    }
    if(b.every(v=>v!==null)) return {winner:"D", line:null};
    return null;
  }

  function showOverlay(w){
    if(w==="D"){
      modalTitle.textContent = "Ergebnis";
      modalBig.textContent = "Remis";
    } else {
      modalTitle.textContent = "Gewinner";
      modalBig.textContent = w;
    }
    overlay.classList.add("show");
    clearTimeout(showOverlay._t);
    showOverlay._t = setTimeout(()=> overlay.classList.remove("show"), 1200);
  }

  function render(){
    cells.forEach((c,i)=>{
      const v = board[i];
      c.textContent = v || "";
      c.classList.toggle("x", v==="X");
      c.classList.toggle("o", v==="O");
      c.classList.remove("win");
      c.disabled = gameOver || v!==null;
    });
    scoreXEl.textContent = scores.X;
    scoreOEl.textContent = scores.O;
    scoreDEl.textContent = scores.D;
    updateMeta();
  }

  function highlight(line){
    if(!line) return;
    line.forEach(i=> cells[i].classList.add("win"));
  }

  function end(result){
    gameOver = true;
    if(result.winner==="D"){
      scores.D++;
      statusText.textContent = "Unentschieden";
      showOverlay("D");
    } else {
      scores[result.winner]++;
      statusText.textContent = result.winner + " gewinnt";
      highlight(result.line);
      showOverlay(result.winner);
    }
    render();
  }

  function switchTurn(){
    current = (current==="X") ? "O" : "X";
    statusText.textContent = current + " ist dran";
    setDotFor(current);
  }

  function randomMove(){
    const empty = board.map((v,i)=> v===null ? i : null).filter(v=>v!==null);
    return empty.length ? empty[Math.floor(Math.random()*empty.length)] : null;
  }
  function strategicMove(){
    if(board[4]===null) return 4;
    const corners=[0,2,6,8].filter(i=>board[i]===null);
    if(corners.length) return corners[Math.floor(Math.random()*corners.length)];
    const edges=[1,3,5,7].filter(i=>board[i]===null);
    if(edges.length) return edges[Math.floor(Math.random()*edges.length)];
    return null;
  }
  function findImmediate(player){
    for(let i=0;i<9;i++){
      if(board[i]!==null) continue;
      const test=board.slice();
      test[i]=player;
      const r=checkWinner(test);
      if(r && r.winner===player) return i;
    }
    return null;
  }
  function minimaxBest(state, player){
    const r = checkWinner(state);
    if(r){
      if(r.winner===BOT) return {score:10};
      if(r.winner===HUMAN) return {score:-10};
      return {score:0};
    }
    const moves=[];
    for(let i=0;i<9;i++){
      if(state[i]!==null) continue;
      const next=state.slice();
      next[i]=player;
      const nextPlayer=(player===BOT)?HUMAN:BOT;
      const out=minimaxBest(next,nextPlayer);
      moves.push({index:i, score: out.score + (player===BOT ? -0.01 : 0.01)});
    }
    let best=moves[0];
    if(player===BOT){
      for(const m of moves) if(m.score>best.score) best=m;
    } else {
      for(const m of moves) if(m.score<best.score) best=m;
    }
    return best;
  }

  function botMove(){
    if(gameOver) return;
    const d = diffSelect.value;
    let move=null;
    if(d==="easy") move=randomMove();
    else if(d==="medium"){
      move = (Math.random()<0.7) ? (findImmediate(BOT) ?? findImmediate(HUMAN) ?? strategicMove() ?? randomMove()) : randomMove();
    } else {
      move = minimaxBest(board, BOT).index;
    }
    if(move!=null) makeMove(move);
  }

  function makeMove(i){
    if(gameOver || board[i]!==null) return;
    board[i]=current;

    const r = checkWinner(board);
    render();
    if(r){ end(r); return; }

    switchTurn();
    if(modeSelect.value==="bot" && current===BOT && !gameOver){
      setTimeout(botMove, 160);
    }
  }

  function reset(keepScores=true){
    board=Array(9).fill(null);
    current="X";
    gameOver=false;
    overlay.classList.remove("show");
    if(!keepScores) scores={X:0,O:0,D:0};
    statusText.textContent="X ist dran";
    setDotFor("X");
    render();
  }

  cells.forEach(cell=>{
    cell.addEventListener("click", ()=>{
      const i = Number(cell.dataset.i);
      if(modeSelect.value==="bot" && current===BOT) return;
      makeMove(i);
    });
  });

  modeSelect.addEventListener("change", ()=> reset(true));
  diffSelect.addEventListener("change", ()=> { if(modeSelect.value==="bot") reset(true); });
  newBtn.addEventListener("click", ()=> reset(true));
  resetScoresBtn.addEventListener("click", ()=> reset(false));

  setDotFor("X");
  updateMeta();
  reset(true);
})();

/* =========================
   SNAKE (Mobile D-Pad)
========================= */
(() => {
  const canvas = document.getElementById("snCanvas");
  const ctx = canvas.getContext("2d");

  const speedSel = document.getElementById("snSpeed");
  const sizeSel = document.getElementById("snSize");
  const newBtn = document.getElementById("snNew");
  const pauseBtn = document.getElementById("snPause");

  const wallBtn = document.getElementById("snWallBtn");
  const wallHint = document.getElementById("snWallHint");

  const statusText = document.getElementById("snStatus");
  const scoreEl = document.getElementById("snScore");

  const overlay = document.getElementById("snOverlay");
  const modalBig = document.getElementById("snModalBig");

  const dpad = document.getElementById("snDpad");

  const css = getComputedStyle(document.documentElement);
  function v(name){ return css.getPropertyValue(name).trim(); }
  const COLOR_SNAKE = v("--mint");
  const COLOR_HEAD  = v("--blue");
  const COLOR_FOOD  = v("--pink");
  const COLOR_GRID  = "rgba(20,48,74,0.22)";
  const GRID_LINE = 1.4;

  let N = 20;
  let tickMs = 120;
  let running = false;
  let paused = false;
  let score = 0;

  let wallsOn = false;
  let snake = [];
  let dir = {x:1,y:0};
  let nextDir = {x:1,y:0};
  let food = {x:10,y:10};

  let rafId = null;
  let lastTick = 0;

  function setCanvasSize(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function speedToMs(v){
    if(v==="slow") return 170;
    if(v==="fast") return 90;
    return 120;
  }

  function updateWallUI(){
    wallBtn.classList.toggle("on", wallsOn);
    wallHint.textContent = wallsOn ? "AN (Wand)" : "AUS (Wrap)";
    statusText.textContent = wallsOn ? "Wand-Modus" : "Wrap-Modus";
  }

  function randEmptyCell(){
    while(true){
      const x = Math.floor(Math.random()*N);
      const y = Math.floor(Math.random()*N);
      if(!snake.some(s=>s.x===x && s.y===y)) return {x,y};
    }
  }

  function resetGame(){
    N = parseInt(sizeSel.value, 10);
    tickMs = speedToMs(speedSel.value);

    score = 0;
    scoreEl.textContent = score;

    running = true;
    paused = false;
    pauseBtn.textContent = "Pause";
    overlay.classList.remove("show");

    const mid = Math.floor(N/2);
    snake = [{x:mid-1,y:mid},{x:mid,y:mid},{x:mid+1,y:mid}];
    dir = {x:1,y:0};
    nextDir = {x:1,y:0};

    food = randEmptyCell();
    statusText.textContent = "Los geht's!";
    canvas.focus();

    lastTick = 0;
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(loop);
    draw();
  }

  function togglePause(){
    if(!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? "Weiter" : "Pause";
    statusText.textContent = paused ? "Pausiert" : "Weiter!";
  }

  function gameOver(reason){
    running = false;
    paused = false;
    statusText.textContent = "Game Over";
    modalBig.textContent = "Punkte: " + score + (reason ? " · " + reason : "");
    overlay.classList.add("show");
  }

  function setDirection(nx, ny){
    if(nx===-dir.x && ny===-dir.y) return;
    nextDir = {x:nx,y:ny};
  }

  function step(){
    dir = nextDir;

    const head = snake[snake.length-1];
    let newHead = {x: head.x + dir.x, y: head.y + dir.y};

    if(wallsOn){
      if(newHead.x < 0 || newHead.x >= N || newHead.y < 0 || newHead.y >= N){
        gameOver("Wand berührt!");
        return;
      }
    } else {
      if(newHead.x < 0) newHead.x = N-1;
      if(newHead.x >= N) newHead.x = 0;
      if(newHead.y < 0) newHead.y = N-1;
      if(newHead.y >= N) newHead.y = 0;
    }

    if(snake.some(s => s.x===newHead.x && s.y===newHead.y)){
      gameOver("In dich selbst!");
      return;
    }

    snake.push(newHead);

    if(newHead.x===food.x && newHead.y===food.y){
      score++;
      scoreEl.textContent = score;
      statusText.textContent = "Lecker!";
      food = randEmptyCell();
    } else {
      snake.shift();
    }
  }

  function draw(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const cell = Math.min(w,h) / N;
    const pad = cell * 0.10;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(210,235,255,0.55)";
    ctx.fillRect(0,0,w,h);

    ctx.lineWidth = GRID_LINE;
    ctx.strokeStyle = COLOR_GRID;
    for(let i=0;i<=N;i++){
      const x = i*cell, y=i*cell;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,N*cell); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(N*cell,y); ctx.stroke();
    }

    ctx.fillStyle = COLOR_FOOD;
    roundRect(food.x*cell+pad, food.y*cell+pad, cell-2*pad, cell-2*pad, Math.max(6,cell*0.22)); ctx.fill();

    for(let i=0;i<snake.length;i++){
      const s = snake[i];
      const isHead = i===snake.length-1;
      ctx.fillStyle = isHead ? COLOR_HEAD : COLOR_SNAKE;
      roundRect(s.x*cell+pad, s.y*cell+pad, cell-2*pad, cell-2*pad, Math.max(6,cell*0.22)); ctx.fill();
    }

    if(wallsOn){
      ctx.strokeStyle = "rgba(20,48,74,0.32)";
      ctx.lineWidth = 6;
      ctx.strokeRect(3,3,N*cell-6,N*cell-6);
    }
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function loop(ts){
    if(!running) return;
    if(!paused){
      if(!lastTick) lastTick = ts;
      const dt = ts - lastTick;
      if(dt >= tickMs){
        lastTick = ts;
        step();
      }
    }
    draw();
    rafId = requestAnimationFrame(loop);
  }

  window.addEventListener("keydown", (e)=>{
    const k=e.key.toLowerCase();
    if(k==="arrowup"||k==="w"){ e.preventDefault(); setDirection(0,-1); }
    else if(k==="arrowdown"||k==="s"){ e.preventDefault(); setDirection(0,1); }
    else if(k==="arrowleft"||k==="a"){ e.preventDefault(); setDirection(-1,0); }
    else if(k==="arrowright"||k==="d"){ e.preventDefault(); setDirection(1,0); }
    else if(k===" "){ e.preventDefault(); togglePause(); }
  }, {passive:false});

  let touchStart=null;
  canvas.addEventListener("touchstart",(e)=>{
    if(!e.touches||!e.touches[0]) return;
    touchStart={x:e.touches[0].clientX,y:e.touches[0].clientY};
  }, {passive:true});

  canvas.addEventListener("touchend",(e)=>{
    if(!touchStart) return;
    const t=(e.changedTouches&&e.changedTouches[0])?e.changedTouches[0]:null;
    if(!t) return;
    const dx=t.clientX-touchStart.x;
    const dy=t.clientY-touchStart.y;
    const ax=Math.abs(dx), ay=Math.abs(dy);
    const thr=18;
    if(ax<thr && ay<thr) return;
    if(ax>ay) setDirection(dx>0?1:-1,0);
    else setDirection(0,dy>0?1:-1);
    touchStart=null;
  }, {passive:true});

  canvas.addEventListener("touchmove",(e)=>e.preventDefault(), {passive:false});

  newBtn.addEventListener("click", resetGame);
  pauseBtn.addEventListener("click", togglePause);
  wallBtn.addEventListener("click", ()=>{ wallsOn=!wallsOn; updateWallUI(); draw(); });

  dpad.querySelectorAll("button").forEach(b=>{
    b.addEventListener("click", ()=>{
      const d=b.dataset.dir;
      if(d==="up") setDirection(0,-1);
      if(d==="down") setDirection(0,1);
      if(d==="left") setDirection(-1,0);
      if(d==="right") setDirection(1,0);
      if(d==="pause") togglePause();
      canvas.focus();
    });
  });

  const ro = new ResizeObserver(()=>{ setCanvasSize(); draw(); });
  ro.observe(canvas.parentElement);

  setCanvasSize();
  updateWallUI();
  draw();
})();

/* =========================
   FLAPPY
========================= */
(() => {
  const canvas = document.getElementById("fbCanvas");
  const ctx = canvas.getContext("2d");

  const diffSel = document.getElementById("fbDiff");
  const modeSel = document.getElementById("fbMode");
  const startBtn = document.getElementById("fbStart");
  const resetBtn = document.getElementById("fbReset");

  const statusEl = document.getElementById("fbStatus");
  const scoreEl = document.getElementById("fbScore");

  const overlay = document.getElementById("fbOverlay");
  const modalBig = document.getElementById("fbModalBig");

  const css = getComputedStyle(document.documentElement);
  const PINK = css.getPropertyValue("--pink").trim();

  let running=false;
  let score=0;

  let bird, pipes, t=0, last=0;
  let gravity=0.42, flap=-7.6;

  function setCanvasSize(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function config(){
    const diff = diffSel.value;
    const mode = modeSel.value;

    let speed = 2.6, gap = 160, spawn = 1500;
    if(diff==="easy"){ speed=2.1; gap=175; spawn=1600; }
    if(diff==="normal"){ speed=2.7; gap=160; spawn=1500; }
    if(diff==="hard"){ speed=3.4; gap=145; spawn=1400; }

    if(mode==="tight") gap -= 18;

    return {speed, gap, spawn};
  }

  function reset(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    bird = {x: w*0.28, y: h*0.5, vy: 0, r: 14};
    pipes = [];
    t = 0; last = 0;
    score = 0;
    scoreEl.textContent = "0";
    statusEl.textContent = "Bereit";
    overlay.classList.remove("show");
    running = false;
    draw();
  }

  function start(){
    reset();
    running = true;
    statusEl.textContent = "Flieg!";
    requestAnimationFrame(loop);
  }

  function addPipe(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const {gap} = config();

    const topMin = 60;
    const topMax = h - 60 - gap;
    const top = Math.random()*(topMax-topMin)+topMin;

    pipes.push({ x: w + 40, w: 64, top, gap, passed:false });
  }

  function flapNow(){ if(running) bird.vy = flap; }

  function hit(){
    running = false;
    statusEl.textContent = "Game Over";
    modalBig.textContent = "Score: " + score;
    overlay.classList.add("show");
  }

  function loop(ts){
    if(!running) return;
    if(!last) last = ts;
    const dt = Math.min(32, ts-last);
    last = ts;

    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const {speed, spawn} = config();

    t += dt;
    if(t > spawn){ t = 0; addPipe(); }

    bird.vy += gravity;
    bird.y += bird.vy;

    if(bird.y - bird.r < 0 || bird.y + bird.r > h) { hit(); draw(); return; }

    for(const p of pipes){
      p.x -= speed;

      const bx = bird.x, by = bird.y, br = bird.r;
      const inX = bx+br > p.x && bx-br < p.x+p.w;
      if(inX){
        const topHit = (by-br < p.top);
        const bottomHit = (by+br > p.top + p.gap);
        if(topHit || bottomHit){ hit(); draw(); return; }
      }

      if(!p.passed && p.x + p.w < bird.x){
        p.passed = true;
        score++;
        scoreEl.textContent = String(score);
      }
    }
    pipes = pipes.filter(p => p.x + p.w > -80);

    draw();
    requestAnimationFrame(loop);
  }

  function draw(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(210,235,255,0.55)";
    ctx.fillRect(0,0,w,h);

    for(const p of pipes){
      ctx.fillStyle = "rgba(20,48,74,0.80)";
      ctx.fillRect(p.x, 0, p.w, p.top);
      ctx.fillRect(p.x, p.top + p.gap, p.w, h - (p.top+p.gap));
      ctx.fillStyle = "rgba(255,255,255,0.18)";
      ctx.fillRect(p.x+8, 0, 10, p.top);
      ctx.fillRect(p.x+8, p.top+p.gap, 10, h-(p.top+p.gap));
    }

    ctx.fillStyle = PINK;
    ctx.beginPath();
    ctx.arc(bird?.x||w*0.28, bird?.y||h*0.5, bird?.r||14, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.beginPath();
    ctx.arc((bird?.x||w*0.28)-5, (bird?.y||h*0.5)-6, 5.5, 0, Math.PI*2);
    ctx.fill();

    if(!running){
      ctx.fillStyle = "rgba(20,48,74,0.75)";
      ctx.font = "700 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Drücke Start – Tippen/Klicken/Space = Flap", 18, 26);
    }
  }

  function onAction(e){ e.preventDefault(); flapNow(); }
  canvas.addEventListener("pointerdown", onAction, {passive:false});
  canvas.addEventListener("touchmove", (e)=> e.preventDefault(), {passive:false});
  window.addEventListener("keydown", (e)=>{
    if(e.key===" "){
      e.preventDefault();
      flapNow();
    }
  }, {passive:false});

  startBtn.addEventListener("click", start);
  resetBtn.addEventListener("click", reset);

  const ro = new ResizeObserver(()=>{ setCanvasSize(); draw(); });
  ro.observe(canvas.parentElement);

  setCanvasSize();
  reset();
})();

/* =========================
   CONNECT 4 (Falling + Bot)
========================= */
(() => {
  const canvas = document.getElementById("c4Canvas");
  const ctx = canvas.getContext("2d");

  const modeSel = document.getElementById("c4Mode");
  const diffSel = document.getElementById("c4Diff");
  const newBtn = document.getElementById("c4New");
  const undoBtn = document.getElementById("c4Undo");

  const dot = document.getElementById("c4Dot");
  const statusEl = document.getElementById("c4Status");
  const metaEl = document.getElementById("c4Meta");

  const overlay = document.getElementById("c4Overlay");
  const modalTitle = document.getElementById("c4ModalTitle");
  const modalBig = document.getElementById("c4ModalBig");

  const css = getComputedStyle(document.documentElement);
  const BLUE = css.getPropertyValue("--blue").trim();
  const PINK = css.getPropertyValue("--pink").trim();
  const BOARD = "rgba(20,48,74,0.80)";
  const HOLE = "rgba(255,255,255,0.20)";

  const COLS=7, ROWS=6;
  let grid = Array.from({length:ROWS}, ()=> Array(COLS).fill(0)); // 0 empty, 1 red, 2 yellow
  let current = 1; // 1 red, 2 yellow
  let over = false;
  let falling = null; // {col,row,y,targetY,player}
  let history = [];

  function setCanvasSize(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function updateMeta(){
    const isBot = modeSel.value==="bot";
    diffSel.disabled = !isBot;
    metaEl.textContent = isBot ? ("Gegen Bot · " + (diffSel.value==="easy"?"Leicht":diffSel.value==="medium"?"Mittel":"Schwer")) : "2 Spieler";
  }

  function setDot(){
    dot.classList.remove("x","o");
    // reuse: x=blue o=pink, aber hier: rot= pink, gelb= blue (sieht sauber aus)
    if(current===1){ dot.classList.add("o"); statusEl.textContent = "Rot ist dran"; }
    else { dot.classList.add("x"); statusEl.textContent = "Gelb ist dran"; }
  }

  function reset(){
    grid = Array.from({length:ROWS}, ()=> Array(COLS).fill(0));
    current = 1;
    over = false;
    falling = null;
    history = [];
    overlay.classList.remove("show");
    updateMeta();
    setDot();
    draw();
  }

  function findRow(col){
    for(let r=ROWS-1; r>=0; r--){
      if(grid[r][col]===0) return r;
    }
    return -1;
  }

  function place(col, player){
    if(over || falling) return;
    const row = findRow(col);
    if(row<0) return;

    history.push(JSON.stringify(grid));
    falling = { col, row, y: -1, player, targetY: row };
  }

  function undo(){
    if(falling) return;
    if(history.length===0) return;
    const prev = history.pop();
    grid = JSON.parse(prev);
    over = false;
    overlay.classList.remove("show");
    current = (current===1?2:1); // zurückdrehen (ein Zug)
    updateMeta();
    setDot();
    draw();
  }

  function winnerOf(player){
    // check 4
    const g = grid;
    const inBounds=(r,c)=> r>=0&&r<ROWS&&c>=0&&c<COLS;
    const dirs = [[0,1],[1,0],[1,1],[1,-1]];
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(g[r][c]!==player) continue;
        for(const [dr,dc] of dirs){
          let ok=true;
          for(let k=1;k<4;k++){
            const rr=r+dr*k, cc=c+dc*k;
            if(!inBounds(rr,cc) || g[rr][cc]!==player){ ok=false; break; }
          }
          if(ok) return true;
        }
      }
    }
    return false;
  }

  function isDraw(){
    return grid[0].every(v=>v!==0);
  }

  function endGame(text){
    over = true;
    modalTitle.textContent = "Ergebnis";
    modalBig.textContent = text;
    overlay.classList.add("show");
  }

  function scorePosition(player){
    // simple heuristic: center preference + lines
    let score=0;
    const center = Math.floor(COLS/2);
    for(let r=0;r<ROWS;r++){
      if(grid[r][center]===player) score+=3;
    }
    // count 2/3 in windows
    const windows=[];
    // horizontal
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS-3;c++) windows.push([[r,c],[r,c+1],[r,c+2],[r,c+3]]);
    // vertical
    for(let r=0;r<ROWS-3;r++) for(let c=0;c<COLS;c++) windows.push([[r,c],[r+1,c],[r+2,c],[r+3,c]]);
    // diag down-right
    for(let r=0;r<ROWS-3;r++) for(let c=0;c<COLS-3;c++) windows.push([[r,c],[r+1,c+1],[r+2,c+2],[r+3,c+3]]);
    // diag down-left
    for(let r=0;r<ROWS-3;r++) for(let c=3;c<COLS;c++) windows.push([[r,c],[r+1,c-1],[r+2,c-2],[r+3,c-3]]);

    for(const w of windows){
      let p=0,e=0,o=0;
      for(const [rr,cc] of w){
        const v=grid[rr][cc];
        if(v===player) p++;
        else if(v===0) e++;
        else o++;
      }
      if(p===4) score+=100000;
      else if(p===3 && e===1) score+=60;
      else if(p===2 && e===2) score+=12;

      if(o===3 && e===1) score-=48; // block opponent threats
    }
    return score;
  }

  function validCols(){
    const cols=[];
    for(let c=0;c<COLS;c++) if(findRow(c)>=0) cols.push(c);
    return cols;
  }

  function simulateDrop(col, player){
    const r = findRow(col);
    if(r<0) return null;
    grid[r][col]=player;
    return r;
  }
  function revertDrop(col, row){
    grid[row][col]=0;
  }

  function botChoose(){
    const diff = diffSel.value;
    const bot = 2, human = 1;

    // easy: random valid
    const cols = validCols();
    if(cols.length===0) return null;
    if(diff==="easy"){
      return cols[Math.floor(Math.random()*cols.length)];
    }

    // medium/hard:
    // 1) immediate win
    for(const c of cols){
      const r=simulateDrop(c, bot);
      const win = winnerOf(bot);
      revertDrop(c,r);
      if(win) return c;
    }
    // 2) block immediate human win
    for(const c of cols){
      const r=simulateDrop(c, human);
      const win = winnerOf(human);
      revertDrop(c,r);
      if(win) return c;
    }

    // medium: pick best heuristic
    if(diff==="medium"){
      let bestC=cols[0], bestS=-1e9;
      for(const c of cols){
        const r=simulateDrop(c, bot);
        const s=scorePosition(bot);
        revertDrop(c,r);
        if(s>bestS){ bestS=s; bestC=c; }
      }
      return bestC;
    }

    // hard: 2-ply minimax (bot -> human response)
    let bestC=cols[0], bestVal=-1e9;
    for(const c of cols){
      const r=simulateDrop(c, bot);
      if(winnerOf(bot)){ revertDrop(c,r); return c; }

      const oppCols = validCols();
      let worst=1e9;
      for(const oc of oppCols){
        const or=simulateDrop(oc, human);
        const val = winnerOf(human) ? -100000 : scorePosition(bot);
        revertDrop(oc,or);
        if(val<worst) worst=val;
      }
      revertDrop(c,r);

      if(worst>bestVal){ bestVal=worst; bestC=c; }
    }
    return bestC;
  }

  function tick(){
    if(falling){
      const rect = canvas.getBoundingClientRect();
      const w=rect.width, h=rect.height;

      const cell = Math.min(w/(COLS+0.6), h/(ROWS+0.6));
      const ox = (w - COLS*cell)/2;
      const oy = (h - ROWS*cell)/2;

      const targetY = oy + falling.targetY*cell + cell/2;
      if(falling.y < 0) falling.y = oy - cell;
      falling.y += Math.max(10, cell*0.22); // falling speed

      if(falling.y >= targetY){
        // land
        grid[falling.row][falling.col] = falling.player;
        falling = null;

        // check win
        if(winnerOf(current)){
          endGame(current===1 ? "Rot gewinnt!" : "Gelb gewinnt!");
        } else if(isDraw()){
          endGame("Remis");
        } else {
          current = (current===1?2:1);
          setDot();
          updateMeta();

          // bot move
          const isBot = modeSel.value==="bot";
          if(isBot && current===2 && !over){
            setTimeout(()=> {
              const c = botChoose();
              if(c!=null) place(c,2);
            }, 220);
          }
        }
      }
    }
    draw();
    requestAnimationFrame(tick);
  }

  function draw(){
    const rect = canvas.getBoundingClientRect();
    const w=rect.width, h=rect.height;
    ctx.clearRect(0,0,w,h);

    // bg
    ctx.fillStyle = "rgba(210,235,255,0.55)";
    ctx.fillRect(0,0,w,h);

    const cell = Math.min(w/(COLS+0.6), h/(ROWS+0.6));
    const ox = (w - COLS*cell)/2;
    const oy = (h - ROWS*cell)/2;

    // board plate
    ctx.fillStyle = BOARD;
    roundRect(ctx, ox-10, oy-10, COLS*cell+20, ROWS*cell+20, 22);
    ctx.fill();

    // holes + chips
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cx = ox + c*cell + cell/2;
        const cy = oy + r*cell + cell/2;

        // hole
        ctx.fillStyle = HOLE;
        ctx.beginPath();
        ctx.arc(cx,cy, cell*0.38, 0, Math.PI*2);
        ctx.fill();

        // chip
        const v = grid[r][c];
        if(v!==0){
          ctx.fillStyle = (v===1) ? PINK : BLUE;
          ctx.beginPath();
          ctx.arc(cx,cy, cell*0.33, 0, Math.PI*2);
          ctx.fill();

          ctx.fillStyle = "rgba(255,255,255,0.35)";
          ctx.beginPath();
          ctx.arc(cx-cell*0.10, cy-cell*0.12, cell*0.12, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    // falling chip
    if(falling){
      const cx = ox + falling.col*cell + cell/2;
      const cy = falling.y;

      ctx.fillStyle = (falling.player===1) ? PINK : BLUE;
      ctx.beginPath();
      ctx.arc(cx, cy, cell*0.33, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.beginPath();
      ctx.arc(cx-cell*0.10, cy-cell*0.12, cell*0.12, 0, Math.PI*2);
      ctx.fill();
    }

    // column hover indicator (optional)
  }

  function roundRect(ctx,x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function colFromPointer(e){
    const rect=canvas.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const w=rect.width, h=rect.height;
    const cell = Math.min(w/(COLS+0.6), h/(ROWS+0.6));
    const ox = (w - COLS*cell)/2;
    const c = Math.floor((px - ox) / cell);
    if(c<0 || c>=COLS) return null;
    return c;
  }

  canvas.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    if(over || falling) return;

    const isBot = modeSel.value==="bot";
    // if bot and it's bot's turn, ignore
    if(isBot && current===2) return;

    const col = colFromPointer(e);
    if(col==null) return;
    place(col, current);
  }, {passive:false});
  canvas.addEventListener("touchmove",(e)=>e.preventDefault(),{passive:false});

  newBtn.addEventListener("click", reset);
  undoBtn.addEventListener("click", undo);
  modeSel.addEventListener("change", ()=> { updateMeta(); reset(); });
  diffSel.addEventListener("change", updateMeta);

  const ro = new ResizeObserver(()=>{ setCanvasSize(); draw(); });
  ro.observe(canvas.parentElement);

  function init(){
    setCanvasSize();
    updateMeta();
    setDot();
    reset();
    requestAnimationFrame(tick);
  }
  init();
})();
</script>
</body>
</html>
